#!/usr/bin/env bash
# Principal Architect review tool for Claude Code projects

set -euo pipefail

# Script directory detection
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Global variables
PROJECT_ROOT=""
DOCS_DIR=""
REPORT_FILE=""
TIMESTAMP=""

# Cleanup function
cleanup() {
    popd > /dev/null 2>&1 || true
}
trap cleanup EXIT

# Function to display usage
usage() {
    echo "Usage: arch-review [OPTIONS]"
    echo ""
    echo "Performs a Principal Architect review of the current project considering:"
    echo "  • AWS Well-Architected Framework"
    echo "  • Azure Well-Architected Framework"
    echo "  • CNCF Cloud Native principles"
    echo "  • Design Patterns"
    echo "  • SOLID Design principles"
    echo "  • Clean Code practices"
    echo "  • CAP Theorem implications"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -d, --dir DIR  Specify project directory (default: current directory)"
    echo ""
    echo "The review report will be written to docs/arch-review-YYYY-MM-DD-HHMMSS.md"
}

# Function to detect project root
detect_project_root() {
    local dir="${1:-$(pwd)}"
    
    # Look for common project indicators
    local indicators=(
        ".git"
        "package.json"
        "pom.xml"
        "Cargo.toml"
        "go.mod"
        "requirements.txt"
        "pyproject.toml"
        "Dockerfile"
        "docker-compose.yml"
        ".gitignore"
    )
    
    local current_dir="$dir"
    while [[ "$current_dir" != "/" ]]; do
        for indicator in "${indicators[@]}"; do
            if [[ -e "$current_dir/$indicator" ]]; then
                PROJECT_ROOT="$current_dir"
                return 0
            fi
        done
        current_dir="$(dirname "$current_dir")"
    done
    
    # If no indicators found, use the provided directory
    PROJECT_ROOT="$dir"
}

# Function to ensure docs directory exists
ensure_docs_dir() {
    DOCS_DIR="${PROJECT_ROOT}/docs"
    echo -e "${BLUE}Target docs directory: ${DOCS_DIR}${NC}"
    
    if [[ ! -d "$DOCS_DIR" ]]; then
        echo -e "${YELLOW}Creating docs directory: ${DOCS_DIR}${NC}"
        if ! mkdir -p "$DOCS_DIR" 2>/dev/null; then
            echo -e "${RED}Error: Failed to create docs directory at ${DOCS_DIR}${NC}" >&2
            echo -e "${RED}Please check write permissions for: $(dirname "$DOCS_DIR")${NC}" >&2
            exit 1
        fi
        echo -e "${GREEN}Successfully created docs directory${NC}"
    else
        echo -e "${GREEN}Docs directory already exists${NC}"
    fi
    
    # Verify we can write to the docs directory
    if [[ ! -w "$DOCS_DIR" ]]; then
        echo -e "${RED}Error: No write permission for docs directory: ${DOCS_DIR}${NC}" >&2
        exit 1
    fi
}

# Function to generate timestamp
generate_timestamp() {
    TIMESTAMP=$(date +"%Y-%m-%d-%H%M%S")
    REPORT_FILE="${DOCS_DIR}/arch-review-${TIMESTAMP}.md"
}

# Function to analyze project structure
analyze_project_structure() {
    local project_files=""
    local tech_stack=""
    local architecture_indicators=""
    
    # Detect technology stack
    if [[ -f "${PROJECT_ROOT}/package.json" ]]; then
        tech_stack="${tech_stack}JavaScript/Node.js, "
    fi
    if [[ -f "${PROJECT_ROOT}/pom.xml" ]]; then
        tech_stack="${tech_stack}Java/Maven, "
    fi
    if [[ -f "${PROJECT_ROOT}/Cargo.toml" ]]; then
        tech_stack="${tech_stack}Rust, "
    fi
    if [[ -f "${PROJECT_ROOT}/go.mod" ]]; then
        tech_stack="${tech_stack}Go, "
    fi
    if [[ -f "${PROJECT_ROOT}/requirements.txt" ]] || [[ -f "${PROJECT_ROOT}/pyproject.toml" ]]; then
        tech_stack="${tech_stack}Python, "
    fi
    if [[ -f "${PROJECT_ROOT}/Dockerfile" ]]; then
        tech_stack="${tech_stack}Docker, "
    fi
    if [[ -f "${PROJECT_ROOT}/docker-compose.yml" ]] || [[ -f "${PROJECT_ROOT}/docker-compose.yaml" ]]; then
        tech_stack="${tech_stack}Docker Compose, "
    fi
    if [[ -f "${PROJECT_ROOT}/kubernetes" ]] || [[ -d "${PROJECT_ROOT}/k8s" ]]; then
        tech_stack="${tech_stack}Kubernetes, "
    fi
    
    # Remove trailing comma and space
    tech_stack="${tech_stack%, }"
    
    echo "$tech_stack"
}

# Function to find and list relevant documents
find_project_docs() {
    local docs_found=""
    
    # Look for ADRs
    if find "${PROJECT_ROOT}" -name "*.md" -path "*/adr/*" -o -name "*ADR*" -o -name "*adr*" 2>/dev/null | grep -q .; then
        docs_found="${docs_found}ADRs found, "
    fi
    
    # Look for README files
    if find "${PROJECT_ROOT}" -name "README*" -type f 2>/dev/null | grep -q .; then
        docs_found="${docs_found}README files, "
    fi
    
    # Look for other documentation
    if [[ -d "${PROJECT_ROOT}/docs" ]]; then
        docs_found="${docs_found}docs directory, "
    fi
    
    # Look for configuration files
    if find "${PROJECT_ROOT}" -name "*.yml" -o -name "*.yaml" -o -name "*.json" -o -name "*.toml" 2>/dev/null | grep -q .; then
        docs_found="${docs_found}configuration files, "
    fi
    
    # Remove trailing comma and space
    docs_found="${docs_found%, }"
    
    echo "$docs_found"
}

# Function to generate the review report
generate_report() {
    local tech_stack=$(analyze_project_structure)
    local project_docs=$(find_project_docs)
    
    echo -e "${BLUE}Writing report to: ${REPORT_FILE}${NC}"
    
    if ! cat > "$REPORT_FILE" << EOF
# Principal Architect Review

**Project:** $(basename "$PROJECT_ROOT")  
**Review Date:** $(date +"%Y-%m-%d %H:%M:%S")  
**Technology Stack:** ${tech_stack:-"Not detected"}  
**Documentation Found:** ${project_docs:-"Limited documentation"}

## Executive Summary

This architectural review evaluates the project against industry best practices and architectural principles. The review covers six key areas: AWS Well-Architected Framework, CNCF Cloud Native principles, Design Patterns, SOLID Design principles, Clean Code practices, and CAP Theorem considerations.

## Review Methodology

This review was conducted using automated analysis of the codebase structure, configuration files, and available documentation. Manual code review and stakeholder interviews may be required for a comprehensive assessment.

## 1. AWS Well-Architected Framework

### Operational Excellence
- **Status:** ⚠️ Requires Review
- **Findings:**
  - [ ] Infrastructure as Code implementation
  - [ ] Automated deployment pipelines
  - [ ] Monitoring and observability setup
  - [ ] Incident response procedures

### Security
- **Status:** ⚠️ Requires Review  
- **Findings:**
  - [ ] Identity and access management
  - [ ] Data encryption at rest and in transit
  - [ ] Security scanning in CI/CD
  - [ ] Secrets management

### Reliability
- **Status:** ⚠️ Requires Review
- **Findings:**
  - [ ] Fault tolerance mechanisms
  - [ ] Backup and recovery procedures
  - [ ] Health checks and monitoring
  - [ ] Multi-AZ/region deployment

### Performance Efficiency
- **Status:** ⚠️ Requires Review
- **Findings:**
  - [ ] Resource optimization
  - [ ] Caching strategies
  - [ ] Load testing implementation
  - [ ] Performance monitoring

### Cost Optimization
- **Status:** ⚠️ Requires Review
- **Findings:**
  - [ ] Resource tagging strategy
  - [ ] Cost monitoring and alerts
  - [ ] Right-sizing of resources
  - [ ] Reserved capacity planning

### Sustainability
- **Status:** ⚠️ Requires Review
- **Findings:**
  - [ ] Energy-efficient architectures
  - [ ] Carbon footprint considerations
  - [ ] Resource utilization optimization

## 2. CNCF Cloud Native Assessment

### Containerization
- **Status:** ${tech_stack//,*/} | grep -q "Docker" && echo "✅ Implemented" || echo "❌ Not Implemented"
- **Findings:**
  - Container usage: $(find "${PROJECT_ROOT}" -name "Dockerfile" 2>/dev/null | wc -l) Dockerfile(s) found
  - Multi-stage builds implementation
  - Security scanning of container images

### Orchestration
- **Status:** ⚠️ Requires Review
- **Findings:**
  - Kubernetes manifests: $(find "${PROJECT_ROOT}" -name "*.yaml" -o -name "*.yml" 2>/dev/null | grep -i k8s | wc -l) found
  - Helm charts availability
  - Service mesh implementation

### Microservices Architecture
- **Status:** ⚠️ Requires Review
- **Findings:**
  - Service decomposition strategy
  - API design and versioning
  - Service discovery mechanisms
  - Circuit breaker patterns

### Observability
- **Status:** ⚠️ Requires Review
- **Findings:**
  - Logging strategy and centralization
  - Metrics collection and visualization
  - Distributed tracing implementation
  - SLI/SLO definition

## 3. Design Patterns Analysis

### Architectural Patterns
- **Status:** ⚠️ Manual Review Required
- **Common Patterns to Evaluate:**
  - [ ] Model-View-Controller (MVC)
  - [ ] Model-View-ViewModel (MVVM)
  - [ ] Repository Pattern
  - [ ] Unit of Work Pattern
  - [ ] CQRS (Command Query Responsibility Segregation)
  - [ ] Event Sourcing

### Creational Patterns
- **Patterns to Review:**
  - [ ] Factory Pattern
  - [ ] Builder Pattern
  - [ ] Singleton Pattern (anti-pattern in cloud native)
  - [ ] Dependency Injection

### Behavioral Patterns
- **Patterns to Review:**
  - [ ] Observer Pattern
  - [ ] Strategy Pattern
  - [ ] Command Pattern
  - [ ] State Pattern

## 4. SOLID Design Principles

### Single Responsibility Principle (SRP)
- **Status:** ⚠️ Code Review Required
- **Evaluation Criteria:**
  - Each class/module has one reason to change
  - Clear separation of concerns
  - Cohesive functionality grouping

### Open/Closed Principle (OCP)
- **Status:** ⚠️ Code Review Required
- **Evaluation Criteria:**
  - Software entities open for extension, closed for modification
  - Use of abstractions and interfaces
  - Plugin/extension mechanisms

### Liskov Substitution Principle (LSP)
- **Status:** ⚠️ Code Review Required
- **Evaluation Criteria:**
  - Derived classes substitutable for base classes
  - Contract compliance in inheritance
  - Behavioral consistency

### Interface Segregation Principle (ISP)
- **Status:** ⚠️ Code Review Required
- **Evaluation Criteria:**
  - Clients not forced to depend on unused interfaces
  - Role-based interface design
  - Minimal interface coupling

### Dependency Inversion Principle (DIP)
- **Status:** ⚠️ Code Review Required
- **Evaluation Criteria:**
  - High-level modules independent of low-level modules
  - Dependency on abstractions, not concretions
  - Inversion of Control (IoC) implementation

## 5. Clean Code Assessment

### Code Quality Metrics
- **Status:** ⚠️ Automated Analysis Required
- **Metrics to Evaluate:**
  - [ ] Cyclomatic complexity
  - [ ] Code duplication percentage
  - [ ] Method/function length
  - [ ] Class size and complexity
  - [ ] Test coverage percentage

### Naming Conventions
- **Evaluation Areas:**
  - [ ] Intention-revealing names
  - [ ] Consistent naming patterns
  - [ ] Avoidance of mental mapping
  - [ ] Searchable names

### Function Design
- **Evaluation Areas:**
  - [ ] Small function size (< 20 lines recommended)
  - [ ] Single level of abstraction
  - [ ] Minimal parameter count (< 3 recommended)
  - [ ] Pure functions where possible

### Comments and Documentation
- **Current State:** $(find "${PROJECT_ROOT}" -name "*.md" 2>/dev/null | wc -l) documentation files found
- **Evaluation Areas:**
  - [ ] Self-documenting code
  - [ ] Necessary comments only
  - [ ] Up-to-date documentation
  - [ ] API documentation

## 6. CAP Theorem Considerations

### Consistency
- **Status:** ⚠️ Architecture Review Required
- **Considerations:**
  - [ ] ACID properties in database transactions
  - [ ] Eventual consistency strategies
  - [ ] Data synchronization mechanisms
  - [ ] Conflict resolution strategies

### Availability
- **Status:** ⚠️ Architecture Review Required
- **Considerations:**
  - [ ] High availability architecture (99.9%+ uptime)
  - [ ] Redundancy and failover mechanisms
  - [ ] Circuit breaker patterns
  - [ ] Graceful degradation strategies

### Partition Tolerance
- **Status:** ⚠️ Architecture Review Required
- **Considerations:**
  - [ ] Network partition handling
  - [ ] Distributed system resilience
  - [ ] Message queue reliability
  - [ ] Consensus algorithms (if applicable)

### Trade-off Analysis
- **Current Architecture Choice:** ⚠️ To Be Determined
- **Recommendations:**
  - Define acceptable consistency levels
  - Establish availability requirements
  - Plan for network partition scenarios
  - Document trade-off decisions

## Key Findings and Recommendations

### Critical Issues
1. **Documentation Gap:** Limited architectural documentation found
2. **Security Review:** Comprehensive security assessment needed
3. **Observability:** Monitoring and logging strategy requires definition
4. **Testing Strategy:** Test coverage and quality assessment needed

### High Priority Recommendations
1. **Create Architecture Decision Records (ADRs)** for major design decisions
2. **Implement comprehensive monitoring** and observability
3. **Establish CI/CD pipeline** with security scanning
4. **Define and document** data consistency strategies
5. **Conduct code quality analysis** using automated tools

### Medium Priority Recommendations
1. Implement container security scanning
2. Create disaster recovery procedures
3. Establish performance benchmarking
4. Review and optimize resource utilization
5. Implement automated testing strategy

### Low Priority Recommendations
1. Evaluate sustainability metrics
2. Consider service mesh implementation
3. Explore chaos engineering practices
4. Review licensing and compliance
5. Plan for multi-region deployment

## Next Steps

1. **Immediate (1-2 weeks):**
   - Set up basic monitoring and logging
   - Create initial ADRs for existing architecture
   - Implement security scanning in CI/CD

2. **Short-term (1-3 months):**
   - Complete comprehensive code review
   - Implement automated testing strategy
   - Establish performance benchmarks

3. **Long-term (3-6 months):**
   - Migration to cloud-native architecture (if applicable)
   - Implementation of advanced observability
   - Disaster recovery testing and validation

## Appendix

### Tools Recommended for Detailed Analysis
- **Code Quality:** SonarQube, CodeClimate, ESLint/Pylint
- **Security:** Snyk, OWASP ZAP, Bandit
- **Performance:** JMeter, Artillery, k6
- **Monitoring:** Prometheus, Grafana, ELK Stack
- **Container Security:** Trivy, Clair, Twistlock

### References
- [AWS Well-Architected Framework](https://aws.amazon.com/architecture/well-architected/)
- [CNCF Cloud Native Definition](https://github.com/cncf/toc/blob/main/DEFINITION.md)
- [Clean Code Principles](https://clean-code-developer.com/)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)
- [CAP Theorem](https://en.wikipedia.org/wiki/CAP_theorem)

---
*This review was generated automatically and should be supplemented with manual code review and stakeholder input.*
EOF
    then
        echo -e "${RED}Error: Failed to write report file: ${REPORT_FILE}${NC}" >&2
        echo -e "${RED}Please check write permissions for: ${DOCS_DIR}${NC}" >&2
        exit 1
    fi
    
    # Verify the file was actually created and has content
    if [[ ! -f "$REPORT_FILE" ]]; then
        echo -e "${RED}Error: Report file was not created: ${REPORT_FILE}${NC}" >&2
        exit 1
    fi
    
    local file_size=$(wc -l < "$REPORT_FILE" 2>/dev/null || echo "0")
    if [[ "$file_size" -lt 10 ]]; then
        echo -e "${RED}Error: Report file appears to be incomplete (${file_size} lines)${NC}" >&2
        exit 1
    fi
    
    echo -e "${GREEN}Report successfully written (${file_size} lines)${NC}"
}

# Main function
main() {
    local project_dir=""
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -d|--dir)
                project_dir="$2"
                shift 2
                ;;
            *)
                echo -e "${RED}Error: Unknown option $1${NC}" >&2
                usage
                exit 1
                ;;
        esac
    done
    
    # Use current directory if none specified
    if [[ -z "$project_dir" ]]; then
        project_dir="$(pwd)"
    fi
    
    # Validate project directory
    if [[ ! -d "$project_dir" ]]; then
        echo -e "${RED}Error: Directory '$project_dir' does not exist${NC}" >&2
        exit 1
    fi
    
    echo -e "${BLUE}Starting Principal Architect Review...${NC}"
    echo -e "${YELLOW}Project Directory: $project_dir${NC}"
    
    # Detect project root
    detect_project_root "$project_dir"
    echo -e "${YELLOW}Detected Project Root: $PROJECT_ROOT${NC}"
    
    # Ensure docs directory exists
    ensure_docs_dir
    
    # Generate timestamp and report filename
    generate_timestamp
    echo -e "${YELLOW}Report will be saved to: $REPORT_FILE${NC}"
    
    # Generate the review report
    echo -e "${BLUE}Generating architectural review report...${NC}"
    generate_report
    
    echo -e "${GREEN}✅ Architectural review completed!${NC}"
    echo -e "${GREEN}Report saved to: $REPORT_FILE${NC}"
    echo ""
    echo -e "${YELLOW}Next Steps:${NC}"
    echo "1. Review the generated report"
    echo "2. Address high-priority recommendations"
    echo "3. Conduct manual code review for detailed analysis"
    echo "4. Schedule follow-up reviews quarterly"
}

# Run main function with all arguments
main "$@"